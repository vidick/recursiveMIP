

\section{Preliminaries}


\paragraph{Iterated exponential}
Let $a,b \in \mathbb{R}$, and let $a > 0$. Let $R \geq 1$ be an integer. We define the iterated exponential function as
\[
	\exp^R_a(b) := \exp^{R-1}_a(a^b)
\]
for $R > 1$, and when $R=1$ define $\exp^1_a(b) = a^b$. Equivalently, 
\[
	\exp^R_a(b) := \underbrace{a^{a^{\cdot^{\cdot^{a^b}}}}}_{R}.
\]
Furthermore, for convenience we will define $\exp^0_a(b) = b$ and $\exp^0_a(-b) = 1/b$ when $b \geq 0$.

\subsection{Quantum information theory}

A quantum register is a named finite dimensional Hilbert space. We use san-serif script to denote registers, such as $\sA$, $\sB$, etc. 

Let $\sA$ denote a register.
\begin{enumerate}
	\item $\Dens(\sA)$ denotes the set of density matrices on $\sA$.
	\item $\Lin(\sA)$ denotes the set of linear operators on $\sA$.
\end{enumerate}


\paragraph{State-dependent distance measures}

For a quantum state $\rho \in \Dens(\sA)$ and psd operators $M,N \in \Lin(\sA)$, we define 
\begin{align}
	\Tr_\rho(M) &:= \Tr(M \rho) \\
	\langle M, N \rangle_\rho &:= \Tr_\rho (M^\dagger N) \\
	\Norm{ M }_\rho & := \sqrt{ \langle M, M \rangle_\rho}.
\end{align}

\begin{lemma}
\label{lem:closeness_to_groundspace}
	Let $\sA, \sR$ be registers. Let $H$ be a positive semidefinite matrix acting on $\sA$ with minimum eigenvalue $0$ and second smallest eigenvalue $\Delta > 0$. If $\ket{\psi}$ is a state on $\sA \sR$ such that $\bra{\psi} H_{\sA} \otimes \Id_{\sR} \ket{\psi} \leq \eps$, then there exists a state $\ket{\theta}$ in $\sA \sR$ such that $H \ket{\theta} = 0$ and
	\[
		\left \| \ket{\psi} - \ket{\theta} \right \| \leq \sqrt{\eps/\Delta}.
	\]
\end{lemma}
\begin{proof}
	Follows from the Gentle Measurement Lemma~\cite{ogawa2002new}.
	\hnote{Say more here?}
\end{proof}

\subsection{Quantum interactive protocols} 

We define general quantum interactive protocols between a quantum verifier $V$ and provers $P_1,P_2,\ldots,P_r$. For simplicity, we will restrict our attention to protocols with a single prover $P$. Extending the discussion to multiple provers will be straightforward. 

We can model a single-prover protocol as follows: our Hilbert space consists of three registers: $\sV, \sM, \sP$. The verifier $V$ acts on registers $\sV$ (the verifier's local memory) and $\sM$ (the message register). The prover $P$ acts on $\sM$ and $\sP$ (the prover's local memory). The $\sV$ register initially starts off in the $\ket{0}$ state, but the $\sM$ and $\sP$ registers are arbitrary. The verifier applies a polynomial-size circuit $V_1$ to $\sV \sM$. The prover then applies some unitary $W_1$ (which in general will not be representable by a polynomial size circuit) to $\sM \sP$. The verifier applies $V_2$ to $\sV \sM$, and so on. This continues for polynomially-many steps until the verifier applies a final circuit $V_k$, and the first output qubit of $\sV$ is measured to determine whether the verifier accepts or rejects.


We can assume without loss of generality that every operation in this protocol is a reflection. The gates applied by the verifier $V$ are either the Hadamard gate ($H$) or the Toffoli gate ($T$) which are reflections. The prover's unitaries $W_1, W_2,\ldots$ can be made reflections by introducing an ancilla qubit that indicates whether the unitary is to be run forward or backward. In other words, every unitary $W$ can be embedded in a reflection as $\wt{W} = \ketbra{1}{0} \otimes W + \ketbra{0}{1} \otimes W^\dagger$. 

We can now describe the execution of this interactive protocol as a sequence of gates $G_1,G_2,\ldots,G_\tau$ corresponding to the sequence of Hadamard and Toffoli gates of the verifier circuits interleaved with the prover's unitaries $W_i$. In other words, the gate sequence $\{G_t\}$ consists entirely of Hadamard and Toffoli gates except for the prover's unitaries. %Note that $\tau = \poly(n)$ since the interactive protocol runs in polynomial time.

\subsection{Complexity classes}

\begin{definition}[Nondeterministic iterated exponential time]
	Let $R$ be a positive integer. Then we define
	\[
		\NEXPR = \NTIME[\exp^R_2(n)]
	\]
\end{definition}
with $n$ being the input size. 

We now define a canonically complete language for $\NEXPR$. Define $\mathcal{L}_R$ to be the set of all instances $\langle M, 1^n \rangle$ such that $M$, when interpreted as a nondeterministic Turing Machine, accepts after $\exp^R_2(n)$ steps on a blank tape as input.

\begin{definition}[$\MIPstar$]
	A language $L$ is in $\MIPstar(m,r)_{f(n)}$ if there is a $m$-player, $r$-round quantum interactive proof for $L$ with completeness-soundness gap $f(n)$, where $n$ is the input size. We write $\MIPstar(m,r) = \MIPstar(m,r)_{1/\poly(n)}$.
\end{definition}

\subsection{Games and strategies}

\paragraph{Non-local games} An $r$-player non-local game $G$ is a tuple $(\mathcal{Q},\mathcal{A},\mu,V)$ where $\mathcal{Q} = \mathcal{Q}_1 \times \cdots \times \mathcal{Q}_r$ and $\mathcal{A} = \mathcal{A}_1 \times \cdots \times \mathcal{A}_r$ are $r$-partite alphabets, $\mu$ is a distribution over $\mathcal{Q}$, and $V: \mathcal{Q} \times \mathcal{A} \to \{0,1\}$ is a verification predicate. 



%In a non-local game, a classical referee (also called the \textbf{verifier}) interacts with two or more quantum players $P_1,\ldots,P_r$. 

Such a non-local game is played in the following manner. Before the game starts, the players distribute a shared state $\rho_{\sP_1 \cdots \sP_r}$ between themselves where player $i$ gets register $\sP_i$. In the game, the referee uses private randomness to sample a tuple of \emph{questions} $(q_1,\ldots,q_r)$ from $\mu$, and sends $q_i$ to player $i$, who then performs local measurements on register $\sP_i$ of $\rho$ and returns the measurement outcome $a_i \in \mathcal{A}_i$ (called an \emph{answer}) to the referee. The referee accepts if and only if $V(q_1,\ldots,q_r,a_1,\ldots,a_r) = 1$. 


\paragraph{Extended non-local (ENL) games} In an extended non-local (ENL) game, a quantum referee (which we will also call the \textbf{Extended Verifier}) interacts with one or more quantum players $P_1,\ldots,P_r$. Before the game starts, the players distribute a shared state $\rho_{\sC \sP_1 \cdots \sP_r}$ where the referee gets register $\sC$, and player $i$ gets register $\sP_i$. 

In the game, the referee measures its part of the state, and based on the measurement outcome $s$, generates questions $q_1,\ldots,q_r$ and sends $q_i$ to player $P_i$, who measures $\sP_i$ (depending on $q_i$) and  responds with answer $a_i$. The referee then decides to accept or reject based on a predicate $V(s,q_1,\ldots,q_r,a_1,\ldots,a_r)$.

An extended verifier can thus be described by three circuits: the first is a quantum circuit for the measurement to be performed on $\sR$, the second is a classical circuit that computes questions to the players, as a function of the input and the measurement outcome, and the third is a classical circuit that computes the referee's decision as a function of the measurement outcome, the questions, and the players' answers. 


\hnote{TODO: Make the presentation of definitions of nonlocal games and ENL games consistent}

\paragraph{Strategies}

A strategy $\mathcal{S}$ for an $r$-player ENL game $G$ consists of a pair $(\rho,\{M_i\})$ where
\begin{enumerate}
	\item $\rho$ is a shared state on registers $\sC \sP_1 \cdots \sP_r$.
	\item For each player $i$, $M_i$ is a map from $\mathcal{Q}_i \times \mathcal{A}_i$ to the set of positive semidefinite operators acting on $\sP_i$, satisfying the constraint that for all $q \in \mathcal{Q}_i$,
	\[
		\sum_{a \in \mathcal{A}_i} M_i(q,a) = \Id_{\sP_i}.
	\]
	That is, for all $q \in \mathcal{Q}_i$, $M_i(q) = \{M_i(q,a)\}_a$ is a POVM on $\sP_i$.
	%For each player $i$, for each question $q \in \mathcal{Q}_i$, a POVM $\{ M_q^a \}_{a \in \mathcal{A}_i}$ acting on $\sP_i$. That is, these operators satisfy $\sum_{a \in \mathcal{A}_i} M_q^a = \Id$.
\end{enumerate}


We now define notions of closeness of strategies. 

\begin{definition}[State-dependent closeness of POVMs]
	Let $\rho \in \Dens(\sA)$ be a state and let $M = \{M^a\}_a,N = \{N^a\}_a$ be two POVMs that have the same set of possible outcomes. Then define 
	\begin{align}
		d_\rho \Paren{ M, N } := \Brac{ \sum_a \Norm{ M^a - N^a }_\rho^2 }^{1/2}.
	\end{align}
\end{definition}


\begin{definition}[Closeness of strategies]
	Let $\mathcal{S} = (\rho,\{M_i\}), \mathcal{S}' = (\rho',\{M_i'\})$ be strategies for an $r$-player ENL game $G$. Then $\mathcal{S}$ is \textbf{$\eps$-close} to $\mathcal{S}'$ if and only if
	\begin{enumerate}
		\item $ \norm{ \rho - \rho'}_{tr} \leq \eps$
		\item For all $i$, for all $q \in \mathcal{Q}_i$, for $\sigma \in \{\rho,\rho'\}$
		\[
		d_\sigma(M_i(q),M_i(q)') \leq \eps.
		\]
	\end{enumerate}
\end{definition}

\begin{lemma}
\label{lem:close_strategies}
	Let $G$ be an ENL game, and let $\mathcal{S},\mathcal{S}'$ be strategies for $G$ that are $\eps$-close. Let $\omega_{\mathcal{S}}(G)$ and $\omega_{\mathcal{S}'}(G)$ denote the success probabilities of $\mathcal{S}$ and $\mathcal{S}'$ respectively in $G$. Then we have that
	\[
		\Abs{ \omega_{\mathcal{S}}(G) - \omega_{\mathcal{S}'}(G) } \leq \eps.
	\]
\end{lemma}
\begin{proof}
	\hnote{Insert proof here.}
\end{proof}

\begin{definition}
Given the description of a family of circuits $V$ for the verifier in an ENL, we let $\omega^*(V)$ denote the maximum acceptance probability for a strategy of the provers in the game. 
\end{definition}


\subsection{Turing machines}
\label{sec:turing_machines}

An \textbf{oblivious Turing machine} is one where the movement of the heads is independent of the input.

\begin{theorem}[Pippenger, Fischer~\cite{pippenger1979relations}]\label{thm:pippenger}
Any $k$-tape Turing machine $M$ that runs in time $T$ can be simulated by a $k$-tape oblivious Turing machine that runs in time $\poly(T)$. Furthermore, the location of the $k$ tape heads at time $1 \leq t \leq T$ can be computed in $\poly \log T$ time.
\end{theorem}


\subsubsection{Simulation of oblivious Turing machines with a quantum circuit}

\begin{lemma}\label{lem:tmsim}
	For all $T$, for every $k$-tape oblivious Turing machine $M$, there exists a quantum circuit $TMSIM(M,T)$ of size $\poly(T)$ where
	\begin{enumerate}
		\item $TMSIM(M,T)$ acts on registers $\sM \sA_1 \ldots \sA_k$
		\item The output of the $\{\sA_j\}$ registers of $TMSIM(M,T)$, when run on input $\ket{0}_{\sM} \otimes \ket{x}_{\sA_1 \cdots \sA_k}$, will be equal to the contents of $M$'s tapes on input $x$ after $T$ steps.
	\end{enumerate}
	Furthermore, there exists a Turing machine $\text{TMSIM-DESC}$ that on input $(M,T,t)$ (where $t$ is written in binary), it will output the $t$'th gate of $TMSIM(M,T)$ in $\poly\log(T)$ time. 
\end{lemma}

\begin{proof}
	The architecture of the circuit $TMSIM(M,T)$ is the following: the registers $\sM$ will store the state of the Turing machine $M$, and $\{\sA_j\}$ represent the work tapes of $M$. Since $M$ is oblivious, the head movement patterns of $M$ are pre-determined. Without loss of generality, each tape head will alternate between sweeping left for $T$ steps and then right for $T$ steps, and the heads will be moved in sequence (i.e., the first tape's head will move first, then the second tape's head will move, and so on). 
	
	Each $\sA_j$ register is $O(T)$ qubits wide, representing the $T$ cells of tape $j$ that $M$ could possibly access. Each movement of the heads of $M$ will correspond to a layer in the circuit; the computation of the head transition function of $M$ will be computed in the $\sM$ registers, which connected via two-qubit gates to the corresponding locations in the $\sA_j$ registers. 
	
	Since the computation of the transition function is some constant that only depends on the description size of $M$, the number of gates in each layer is a constant. Thus the total gate complexity of this circuit is $O(T)$. Notice that the gate sequence of each layer is the same, except the gates that cross between $\sM$ and the $\{\sA_j\}$ registers will be different depending on which cells of the tapes are supposed to be read at that layer. 
	
	Thus it is clear that it only takes $\poly\log T$ time to compute any desired gate of the circuit $TMSIM(M,T)$.
\end{proof}

\subsection{Circuits}

Analogously to the circuit $TMSIM$ that simulates a Turing Machine, we require the notion of universal circuit $CKTSIM$ that simulates an arbitrary circuit. 

\begin{lemma}\label{lem:cktsim}
For every integer $n$ there is a classical (resp. quantum) circuit $CKTSIM$ of size $\poly(n)$ that operates on $2n$ bits and is such that for any input $(C,x)$ where $x\in\{0,1\}^n$ and $C$ is the description of a classical (resp. quantum) circuit operating on at most $n$ bits returns $C(x)$. 
\end{lemma}

