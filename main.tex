\documentclass[11pt,letterpaper]{article}
\usepackage[utf8x]{inputenc}
\usepackage{float}
\usepackage{quoting}
\quotingsetup{vskip=0pt,leftmargin=20pt,rightmargin=20pt}

% options for preamble

\def\showauthornotes{0}
\def\showtableofcontents{0} 
\def\showkeys{0}
\def\showdraftbox{0}
\def\showcolorlinks{1}
\def\usemicrotype{1}
\def\showfixme{0}
\def\showdefine{0}

\input{macros}
\setcounter{page}{1}

%%%%%%%%%%%% Paper specific macros

% paper-specific packages
\usepackage{relsize}
\usepackage[font=footnotesize]{caption}
\usepackage{yfonts}

% abbreviations and paper-specific macros
\newcommand{\Id}{\mathop{\mathrm{Id}}\!\mathinner{}}
\newcommand{\pE}{\tilde {\mathbb E}}
\newcommand{\what}[1]{\widehat{#1}}
\newcommand{\wt}[1]{\widetilde{#1}}
\newcommand{\comp}[1]{\overline{#1}}

\newcommand{\Span}{\mathsf{Span}}
\newcommand{\simp}{\triangle}


\newcommand*{\annotaterel}[2]{\stackrel{\scriptscriptstyle\text{#1}}{#2}}

\DeclareUrlCommand\email{}


\newcommand{\tnote}[1]{\textcolor{magenta}{\small {\textbf{(Thomas:} #1\textbf{)
      }}}}

\usepackage{appendix}
\usepackage{amssymb}
 %\setlength\parindent{0pt}
\usepackage{amsfonts}
\usepackage{latexsym}
\usepackage{amsmath}


\usepackage[normalem]{ulem}
\usepackage{todonotes}
\newcommand{\hnote}[1]{\todo[inline, color=green!30]{\small{Henry: #1}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\ket}[1]{|#1\rangle}
\newcommand{\bra}[1]{\langle#1|}
\newcommand{\bigket}[1]{\left |#1 \right \rangle}
\newcommand{\bigbra}[1]{\left \langle#1 \right|}
\newcommand{\ip}[2]{\langle #1 | #2 \rangle}
\newcommand{\ketbra}[2]{|#1\rangle\! \langle #2|}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\sP}{{\mathsf{P}}}
\newcommand{\sC}{{\mathsf{C}}}
\newcommand{\sS}{{\mathsf{S}}}
\newcommand{\sR}{{\mathsf{R}}}
\newcommand{\sZ}{{\mathsf{Z}}}
\newcommand{\sV}{{\mathsf{V}}}
\newcommand{\sM}{{\mathsf{M}}}
\newcommand{\sA}{{\mathsf{A}}}
\newcommand{\sX}{{\mathsf{X}}}
\newcommand{\sE}{{\mathsf{E}}}

%\newcommand{\cP}{{\mathcal{P}}}
%\newcommand{\cC}{{\mathcal{C}}}
%\newcommand{\cR}{{\mathcal{R}}}
%\newcommand{\cZ}{{\mathcal{Z}}}
%\newcommand{\cL}{{\mathcal{L}}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\reg}[1]{{\textsf{#1}}}
\newcommand{\proj}[1]{\ket{#1}\!\bra{#1}}
\newcommand{\Es}[1]{\textsc{E}_{#1}}


\newcommand{\NEXPR}{{\sf NEXP}^{(R)}}
\newcommand{\NTIME}{{\sf NTIME}}
\newcommand{\NEXP}{{\sf NEXP}}
\newcommand{\MIPstar}{{\sf MIP^*}}

\title{Recursive compression of MIP* protocols}
\date{}


\begin{document}

\maketitle


\section{Preliminaries}



\paragraph{Iterated exponential}
Let $a,b \in \mathbb{R}$, and let $a > 0$. Let $R \geq 1$ be an integer. We define the iterated exponential function as
\[
	\exp^R_a(b) := \exp^{R-1}_a(a^b)
\]
for $R > 1$, and when $R=1$ define $\exp^1_a(b) = a^b$. Equivalently, 
\[
	\exp^R_a(b) := \underbrace{a^{a^{\cdot^{\cdot^{a^b}}}}}_{R}.
\]
Furthermore, for convenience we will define $\exp^0_a(b) = b$ and $\exp^0_a(-b) = 1/b$ when $b \geq 0$.


\subsection{Quantum interactive protocols} 

We define general quantum interactive protocols between a quantum verifier $V$ and provers $P_1,P_2,\ldots,P_r$. For simplicity, we will restrict our attention to protocols with a single prover $P$. Extending the discussion to multiple provers will be straightforward. 

We can model a single-prover protocol as follows: our Hilbert space consists of three registers: $\sV, \sM, \sP$. The verifier $V$ acts on registers $\sV$ (the verifier's local memory) and $\sM$ (the message register). The prover $P$ acts on $\sM$ and $\sP$ (the prover's local memory). The $\sV$ register initially starts off in the $\ket{0}$ state, but the $\sM$ and $\sP$ registers are arbitrary. The verifier applies a polynomial-size circuit $V_1$ to $\sV \sM$. The prover then applies some unitary $W_1$ (which in general will not be representable by a polynomial size circuit) to $\sM \sP$. The verifier applies $V_2$ to $\sV \sM$, and so on. This continues for polynomially-many steps until the verifier applies a final circuit $V_k$, and the first output qubit of $\sV$ is measured to determine whether the verifier accepts or rejects.


We can assume without loss of generality that every operation in this protocol is a reflection. The gates applied by the verifier $V$ are either the Hadamard gate ($H$) or the Toffoli gate ($T$) which are reflections. The prover's unitaries $W_1, W_2,\ldots$ can be made reflections by introducing an ancilla qubit that indicates whether the unitary is to be run forward or backward. In other words, every unitary $W$ can be embedded in a reflection as $\wt{W} = \ketbra{1}{0} \otimes W + \ketbra{0}{1} \otimes W^\dagger$. 

We can now describe the execution of this interactive protocol as a sequence of gates $G_1,G_2,\ldots,G_\tau$ corresponding to the sequence of Hadamard and Toffoli gates of the verifier circuits interleaved with the prover's unitaries $W_i$. In other words, the gate sequence $\{G_t\}$ consists entirely of Hadamard and Toffoli gates except for the prover's unitaries. %Note that $\tau = \poly(n)$ since the interactive protocol runs in polynomial time.

\subsection{Complexity classes}

\begin{definition}[Nondeterministic iterated exponential time]
	Let $R$ be a positive integer. Then we define
	\[
		\NEXPR = \NTIME[\exp^R_2(n)]];,
	\]
\end{definition}
with $n$ being the input size. 

We now define a canonically complete language for $\NEXPR$. Define $\mathcal{L}_R$ to be the set of all instances $\langle M, 1^n \rangle$ such that $M$, when interpreted as a nondeterministic Turing Machine, accepts after $\exp^R_2(n)$ steps on a blank tape as input.

\begin{definition}[$\MIPstar$]
	A language $L$ is in $\MIPstar(m,r)$ if there is a $m$-player, $r$-round quantum interactive proof for $L$.
\end{definition}





\subsection{Games}

\paragraph{Extended non-local (ENL) games} In an extended non-local (ENL) game, a quantum referee (which we will also call the \textbf{Extended Verifier}) interacts with one or more quantum players $P_1,\ldots,P_r$. Before the game starts, the players distribute a shared state $\rho_{\sR \sP_1 \cdots \sP_r}$ where the referee gets register $\sR$, and player $i$ gets register $\sP_i$. 

In the game, the referee measures its part of the state, and based on the measurement outcome $s$, generates questions $q_1,\ldots,q_r$ and sends $q_i$ to player $P_i$, who measures $\sP_i$ (depending on $q_i$) and  responds with answer $a_i$. The referee then decides to accept or reject based on a predicate $V(s,q_1,\ldots,q_r,a_1,\ldots,a_r)$.

An extended verifier can thus be described by three circuits: the first is a quantum circuit for the measurement to be performed on $\sR$, the second is a classical circuit that computes questions to the players, as a function of the input and the measurement outcome, and the third is a classical circuit that computes the referee's decision as a function of the measurement outcome, the questions, and the players' answers. 

\begin{definition}
Given the description of a family of circuits $V$ for the verifier in an ENL, we let $\omega^*(V)$ denote the maximum acceptance probability for a strategy of the provers in the game. 
\end{definition}

%\begin{theorem}[Single-shot compression]
%	Let $G$ be an $r$-player ENL game such that the extended verifier circuit has size $S$, and furthermore there exists a gate Turing Machine $T_G$ such that on input $1 \leq t \leq S$ (written in binary), $T_G$ outputs the description of the $t$'th gate in $S$ in time $O(\poly \log(S))$. Then there exists an $r+1$-player ENL game $G'$ such that the extended verifier has size $O(\poly \log(S))$, and has value 
%	\[
%		1 - (1 - \omega^*(G))/\poly(S).
%	\]
%	Furthermore, there exists a gate Turing Machine $T_{G'}$ that specifies the $t$'th gate of the extended verifier of $G'$ in $\poly \log \log(S)$ time.
%\end{theorem}

\subsection{Turing machines}
\label{sec:turing_machines}

An \textbf{oblivious Turing machine} is one where the movement of the heads is independent of the input.

\begin{theorem}[Pippenger, Fischer~\cite{pippenger1979relations}]\label{thm:pippenger}
Any $k$-tape Turing machine $M$ that runs in time $T$ can be simulated by a $k$-tape oblivious Turing machine that runs in time $\poly(T)$. Furthermore, the location of the $k$ tape heads at time $1 \leq t \leq T$ can be computed in $\poly \log T$ time.
\end{theorem}


\subsubsection{Simulation of oblivious Turing machines with a quantum circuit}

\begin{lemma}\label{lem:tmsim}
	For all $T$, for every $k$-tape oblivious Turing machine $M$, there exists a quantum circuit $TMSIM(M,T)$ of size $\poly(T)$ where
	\begin{enumerate}
		\item $TMSIM(M,T)$ acts on registers $\sM \sA_1 \ldots \sA_k$
		\item The output of the $\{\sA_j\}$ registers of $TMSIM(M,T)$, when run on input $\ket{0}_{\sM} \otimes \ket{x}_{\sA_1 \cdots \sA_k}$, will be equal to the contents of $M$'s tapes on input $x$ after $T$ steps.
	\end{enumerate}
	Furthermore, there exists a Turing machine $\text{TMSIM-DESC}$ that on input $(M,T,t)$ (where $t$ is written in binary), it will output the $t$'th gate of $TMSIM(M,T)$ in $\poly\log(T)$ time. 
\end{lemma}

\begin{proof}
	The architecture of the circuit $TMSIM(M,T)$ is the following: the registers $\sM$ will store the state of the Turing machine $M$, and $\{\sA_j\}$ represent the work tapes of $M$. Since $M$ is oblivious, the head movement patterns of $M$ are pre-determined. Without loss of generality, each tape head will alternate between sweeping left for $T$ steps and then right for $T$ steps, and the heads will be moved in sequence (i.e., the first tape's head will move first, then the second tape's head will move, and so on). 
	
	Each $\sA_j$ register is $O(T)$ qubits wide, representing the $T$ cells of tape $j$ that $M$ could possibly access. Each movement of the heads of $M$ will correspond to a layer in the circuit; the computation of the head transition function of $M$ will be computed in the $\sM$ registers, which connected via two-qubit gates to the corresponding locations in the $\sA_j$ registers. 
	
	Since the computation of the transition function is some constant that only depends on the description size of $M$, the number of gates in each layer is a constant. Thus the total gate complexity of this circuit is $O(T)$. Notice that the gate sequence of each layer is the same, except the gates that cross between $\sM$ and the $\{\sA_j\}$ registers will be different depending on which cells of the tapes are supposed to be read at that layer. 
	
	Thus it is clear that it only takes $\poly\log T$ time to compute any desired gate of the circuit $TMSIM(M,T)$.
\end{proof}

\subsection{Circuits}

Analogously to the circuit $TMSIM$ that simulates a Turing Machine, we require the notion of universal circuit $CKTSIM$ that simulates an arbitrary circuit. 

\begin{lemma}\label{lem:cktsim}
For every integer $n$ there is a classical (resp. quantum) circuit $CKTSIM$ of size $\poly(n)$ that operates on $2n$ bits and is such that for any input $(C,x)$ where $x\in\{0,1\}^n$ and $C$ is the description of a classical (resp. quantum) circuit operating on at most $n$ bits returns $C(x)$. 
\end{lemma}


\section{Recursive compression}

We present our recursive $\MIPstar$ compression scheme in this section. The main result we prove is the following:

\begin{theorem}
	There exists a deterministic algorithm $A$ that on input $\langle M, 1^n, R \rangle$ outputs a $(\kappa(R) + 8)$-prover one-round game $G_{M,n,R}$ such that 
\begin{align*}
		\omega^*(G_{M,n,R}) &= 1  \quad & \text{if } \langle M,1^n \rangle\in \mathcal{L}_R \\
		\omega^*(G_{Mn,r,}) &\leq 1 - \exp^{R-1}_2(-cn) \quad &\text{if } \langle M,1^n \rangle\notin \mathcal{L}_R.
\end{align*}
Furthermore, $A$ runs in time $\poly(n) + \poly\log(R)$.	
\end{theorem}

Here, $\kappa(R) = 2R$. \hnote{Subject to change.} The main idea is to carefully compose the $\MIPstar$ compression scheme of~\cite{ji2016compression} $R$ times, each time shrinking the completeness-soundness gap by an exponential. 

\subsection{Turing machines types}

\paragraph{Gate Turing Machine (GTM)} A Turing machine $G$ is a Gate Turing Machine (GTM) for a family of circuits $\{C_{n,r}\}$ if $G$ takes as input $n$ (an integer in binary), $r$ (another integer in binary), and $t$ (an integer $1\leq t\leq n$ written in binary), and in $\poly(\log n)$ time outputs the description of the $t$-th gate of $C_{n,r}$. 

We let $CKT(G,1^n,r)$ denote the circuit $C_{n,r}$ whose gates are computed by $G$ on input $(n,r,t)$.

\paragraph{Verifier TM (VTM)} A VTM takes as input $1^n$, a string $w$ of length at most $n$, and an auxiliary input $V$. %an integer $r$ in binary, a string $w$ of length at most $n$,  and descriptions of GTMs $M$ and $G$. 
It can be used as a building block in the description of a verifier circuit in an ENL. We refer to Section~\ref{sec:vtm} for a complete specification. 

\subsection{Turing machines}

\paragraph{Universal Extended Verifier GTM, $G_{UEVC}$} This is a GTM for $\{UEVC_{n,r}\}$. On input $n$, $r$ and $t$ it computes the $t$-th gate of $UEVC_{n,r}$.

\paragraph{Universal Extended VTM, $V_{UEVC}$} This is a VTM that is used in the circuit $UEVC$. The auxiliary input $V$ is interpreted as $(r,G,M)$ where $r$ is an integer in binary, $G$ is a GTM and $V$ is a VTM. It is described in Section~\ref{sec:vtm-lambda}. 

\paragraph{Natarajan-Vidick VTM, $V_{NV}$} This is a VTM that is called in the final stage of the recursive composition. It takes input $(1^n,w,M)$ where $M$ is interpreted as a non-deterministic Turing machine $M$. The VTM $V_{NV}$ computes the questions and checks the answers as required in the Natarajan-Vidick protocol (see the following Theorem) with $2$ provers to decide whether $\langle M, 1^n \rangle \in \mathcal{L}_1$.

\begin{theorem}[\cite{natarajan2017two}]\label{thm:nv}
%	$\NEXP$ is contained in $\MIPstar(2,1)$.
There exists an $\delta > 0$ such that the following holds. Let $M$ be a nondeterministic Turing machine, and let $\omega$ denote the maximum acceptance probability of the two prover ENL that is executed by the VTM $V_{NV}$ on input $(1^n,w,M)$ where $w$ is a uniformly random $n$-bit string. If $\langle M, 1^n \rangle \in \mathcal{L}_1$, then $\omega = 1$. Otherwise $\omega \leq 1 - \delta$. 
\end{theorem}

\subsection{Circuits}
\label{sec:circuits}

\paragraph{Universal Extended Verifier Circuit, $UEVC_{n,r}$} This is a family of circuits for an $\kappa(r)$-prover extended verifier of size $\poly(n)$. The universal extended verifier takes an input $(G,V,M)$. It expects $G$ to be the description of a GTM for some circuit family, $V$ to be a Verifier Turing Machine that executes a $2$-prover game, and $M$ to be a non-deterministic Turing machine. % $M$ to be the description of 
We let $N = 2^n$.
\begin{itemize}
\item If $r=1$ the verifier plays the $2$-prover game that is executed by VTM $V$ on input $(1^n,w,M)$, where $w$ is a random string.

\item If $r>0$ the verifier executes the $\kappa(r)$-prover extended game that corresponds to checking the history state for the $r$-prover extended verifier whose circuit is $CKT(G,1^N,r-1)$, with input to that circuit being $(G,V,M)$. Note that $UEVC_{n,r}$ cannot compute the entirety of $CKT(G,1^N,r-1)$ in $\poly(n)$ time. But it is enough for $UEVC_{n,r}$ to use the procedure $G(N,r-1,t)$ for a random value of $1\leq t\leq N$.
\end{itemize}

\begin{proposition}
\label{prop:uevc_soundness}

	Let $G_{UEVC}$ be the GTM for the circuit family $\{UEVC_{n,r}\}$, let $V$ be a VTM for a $2$-prover game, and let $M$ be a nondeterministic Turing machine. For any integer $n$ and $r$ let $\omega_{n,r} = \omega^*(UEVC_{n,r})$, when the input to $UEVC_{n,r}$ is $(G_{UEVC},V_{NV},M)$. 
	
	Then for any integer $n$, $N=2^n$, and $r$,
	\begin{itemize}
	\item \emph{(Completeness)} If $\omega_{N,r}=1$ then $\omega_{n,r+1}=1$.
	\item \emph{(Soundness)} In all cases,
	\[
		\omega_{n,r+1} \,\leq\, 1 - \frac{1 - \omega_{N,r}}{\poly(N)}\;.
	\]
	\end{itemize}
\end{proposition}


\begin{corollary}
Let $V_{NV}$ be the Natarajan-Vidick VTM. Let $\langle M,1^n \rangle$ be an instance of $\mathcal{L}_R$. There exists a constant $c > 0$ such that the $\kappa(R)$-prover extended verifier specified by the circuit $UEVC_{n,R}$ on input $(G_{UEVC},V_{NV},M)$ has value 
\begin{align*}
		&= 1  \quad & \text{if } \langle M,1^n \rangle\in \mathcal{L}_R \\
		&\leq 1 - \exp^{R-1}_2(-cn) \quad &\text{if } \langle M,1^n \rangle\notin \mathcal{L}_R
\end{align*}
where recall $\exp^0_a(-b) = 1/b$ by definition for $b \geq 0$.
\end{corollary}
\begin{proof}
	For all $m$, the value $\omega_{m,1}$ when the circuit $UEVC_{m,1}$ is run on input $(G_{UEVC},V_{NV},M)$ is $1$ if $\langle M,1^m \rangle$ is in $\mathcal{L}_1$ and is at most $1 - \delta$ otherwise for some universal constant $\delta > 0$.
	
	Applying the previous Proposition repeatedly, we obtain that if $\langle M,\exp^{R-1}_2(n) \rangle \in \mathcal{L}_1$, or equivalently if $\langle M,1^n \rangle \in \mathcal{L}_R$, then
	\[
		\omega_{n,R} = \omega_{2^n,R-1} = \cdots = \omega_{\exp^{R-1}_2(n),1} = 1.
	\]
	Otherwise, if  $\langle M,1^n \rangle \notin \mathcal{L}_R$, then we have
	\begin{align*}
		\omega_{n,R} &\leq 1 - \poly(2^{-n})(1-\omega_{2^n,R-1}) \\
					&\leq 1 - \poly(\exp^2_2(-n))(1- \omega_{\exp^2_2(n),R-2}) \\
					&\vdots \\
					&\leq 1 - \poly(\exp^{R-1}_2(-n))(1-\omega_{\exp^{R-1}_2(n),1}) \\
					&\leq 1 - \exp^{R-1}_2(-cn).
	\end{align*}
\end{proof}


\section{Detailed specifications}

\subsection{Table of notation}

For the reader's convenience, we include a table of notation.

\begin{figure}[H]
\begin{center}
    \begin{tabular}{ | l | p{10cm} |}
    \hline
    \textbf{Notation} & \textbf{Explanation} \\ \hline
    $\kappa(r)$ 		& Upper bound on the number of provers that the verifier $UEVC_{n,r}$, on input $(G_{UEVC},V_{NV},M)$, will interact with.  \\ \hline
    
    $G_{UEVC}(n,r,t)$ 			& The Gate Turing Machine (GTM) for the circuit family $\{ UEVC_{n,r} \}$ \\ \hline
    
    $V_{UEVC}(r,G,M)$			& The Verifier Turing Machine (VTM) that is used in $UEVC$ \\ \hline
    \end{tabular}
\end{center}
\caption{Table of notation}
\end{figure}

\begin{figure}[H]
\begin{center}
    \begin{tabular}{ | l | p{10cm} |}
    \hline
    \textbf{Register} & \textbf{Usage}\\ \hline
    $\sC$			& Register that is prepared by provers; supposed to hold the clock register 			\\ \hline
    $\sV_{in}$ 		& The register that stores the input string 	 \\ \hline
    $\sV_{work}$	& The workspace register 									\\ \hline
    $\sM_i$			& Message register that is passed to and from  the $i$'th prover	  \\ \hline
%    $\sV_{out}$		& Stores the output							&			\\ \hline
    \end{tabular}
\end{center}
\caption{Table of registers}
\end{figure}

\subsection{$UEVC$}

\label{sec:specs}

The circuit $UEVC_{n,r}$ is meant to be interpreted as the verifier in an ENL game with $\kappa(r)$ provers, where $\kappa(r)$ is a function to be determined later (but this function will be $O(r)$). It receives the input triple $x = (G,V,M)$ in a register $\sV_{in}$. The circuit $UEVC_{n,r}$ is specified by three subcircuits, which all have access to $\sV_{in}$ and a register $\sV_{work}$ which is a sufficiently large ancilla register:

\begin{enumerate}
\item A quantum circuit $C_M$ that acts on $\sV_{in}$, $\sV_{work}$, as well as a quantum register $\sC$, and returns a classical outcome $s$. %in register $\sV_{mo}$;
\item A classical circuit $C_Q$ that acts on $\sV_{in}$, $\sV_{work}$ %and $\sV_{mo}$ 
and computes an $\kappa(r)$-tuple of queries $(q_1,\ldots,q_{\kappa(r)})$, where query $q_i$ is written on register $\sM_i$;
\item A classical circuit $C_A$ that acts on registers $\sV_{in}$, $\sV_{work}$, %$\sV_{mo}$, 
and $\sM_{i}$, and writes a single bit of output in the first qubit of register $\sV_{work}$. % register $\sV_{out}$.  
\end{enumerate}
The way these circuits are interpreted as a verifier in an ENL is as follows. First, the circuit $C_M$ is executed on the input $x$ and the contents of the quantum register $\sC$, that is assumed to contain the provers' first quantum message. The outcome $s$ of the measurement is then passed along to circuit $C_Q$, that also has access to the input $x$ and the workspace $\sV_{work}$ and computes questions $q_i$ in registers $\sM_{i}$ for $i\in\{1,\ldots,\kappa(r)\}$. Prover $i$ is sent register $\sM_i$, on which it writes its answer $a_i$. Finally, circuit $C_A$ has access to the input $x$, the workspace $\sV_{work}$, the measurement outcome $s$, and the answers $a_i$ in registers $\sM_i$, and it computes the referee's decision in the protocol, and stores the decision bit in the first qubit of $\sV_{work}$. (We assume that the workspace $\sV_{work}$ stores a copy of the questions $\{q_i\}$ as well as the random strings that are used for each of the three circuits). 

We wish to specify these three circuits in a way that makes it clear that the associated GTM $G_{UEVC}$, which on input $(n,r,t)$ computes the $t$-th gate of $UEVC_{n,r}$, can be executed in time polynomial in its input length, and in particular polylogarithmic in $n$. To make this possible we introduce an intermediate notion of \emph{Verifier Turing Machine}. 

\subsection{ Verifier Turing Machines}
\label{sec:vtm}

A Verifier Turing Machine (VTM) is a Turing machine description of the computations that an extended verifier is supposed to perform: for example, to compute the queries $\{q_i\}$ or to compute whether to accept or reject, depending on the provers' answers.


A VTM has the following types of tapes:
\begin{enumerate}
	\item Input tape. This tape is used to store the input to the VTM: $1^n$ and a string $V$ of length at most $n$. 
	\item Work tape. This is where all the computation takes place.
	\item Communication tapes. There are two tapes of this kind: the measurement outcome tape and the player answer tape. 
	\item Output tapes. There are three tapes of this kind: the measurement specification tape, the player question tape, and the referee decision tape. 
\end{enumerate}
In addition, a VTM has the following structure. When executed on a properly formatted input $(1^n,V)$ the VTM runs in exactly $3p(n)$ time steps, where $p(n)$ is a fixed polynomial that is a property of the VTM. Moreover, the $3p(n)$ time steps can be divided into three phases of equal length with the following properties: 
\begin{enumerate}
\item \textsc{ClockMeasurement} phase (timesteps $1$ through $p(n)$). During this phase the VTM only accesses the input tape (read only), the work tape, and the measurement specification tape (write only). At the end of the phase the measurement specification tape contains the description of a polynomial-size quantum circuit $C_M$.  
\item  \textsc{GenQuestions} phase (timesteps $p(n) +1$ through $2p(n)$). During this phase the VTM only accesses the input tape (read only), the work tape, the measurement outcome tape (read only), and the player question tape (write only). Assuming that at the beginning of the phase the measurement outcome tape contains a valid measurement outcome,\footnote{What we mean by ``valid'' will become clear when we show how a VTM is used to specify a verifier circuit in Section~\ref{sec:uevc}.} at the end of the phase the player question tape contains the description of an $\kappa(r)$-tuple of questions. 
\item \textsc{CheckAnswers} phase (timesteps $2p(n) + 1$ through $3p(n)$). During this phase the VTM only accesses the input tape (read only), the work tape, the measurement outcome tape (read only), the player answer tape (read only), and the referee decision tape (write only). Assuming that at the beginning of the phase the measurement outcome tape contains a valid measurement outcome, and the player answer tape contains a valid $\kappa(r)$-tuple of answers, at the end of the phase the referee decision tape contains a single bit. 
\end{enumerate}

\subsection{The VTM $V_{UEVC}$}
\label{sec:vtm-lambda}

We now specify a specific VTM $V_{UEVC}$. The VTM is specified in high level pseudocode in Figure~\ref{fig:lambda}. It receives input $(1^n,w,V)$, where $V$ is interpreted as a tuple $(r,G,V,M)$ where $r$ is an integer written in binary, $G$ is a Gate Turing Machine, $V$ is another VTM, and $M$ is a nondeterministic Turing machine. The input string $w$ is used to determine all random choices made by $V_{UEVC}$.

\begin{figure}[H]
\begin{center}
\framebox{
\begin{minipage}{0.9\textwidth}
    Input: $(1^n,w,r,G,V,M)$
    \begin{itemize}
    	\item If $r = 1$, run the VTM specified by $V$ on input $(1^n,w,M)$.
	
		\item If $r > 1$, do the following. Using the string $w$, determine a type of test to be performed, among \emph{Pauli check}, \emph{Propagation check}, \emph{Input check}, and \emph{Output check}. Once a test type has been chosen, the three phases of the VTM are specified by one of Figures~\ref{fig:pauli_check},~\ref{fig:prop_check},~\ref{fig:input_check}, or Figure~\ref{fig:output_check}.

		\end{itemize}
    
\end{minipage}
}

\end{center}
\caption{The VTM $V_{UEVC}$}
\label{fig:lambda}
\end{figure}

\subsection{The circuit $UEVC_{n,r}$}

The three circuits that constitute $UEVC_{n,r}$ are described in Figure~\ref{fig:uevc}. Each of them is essentially an elaborate Turing machine simulator that emulates a phase of $V$. Recall the specification of the registers on which the circuits $UEVC_{n,r}$ operate given at the start of Section~\ref{sec:specs}. 



\begin{figure}[H]
\begin{center}
\framebox{
\begin{minipage}{0.9\textwidth}
    Input: The description of a GTM $G$, a VTM $V$, and a nondeterministic Turing machine $M$.
	  \begin{enumerate}
        \item (\textbf{Measurement circuit}) Use a quantum circuit to compute a random string $w \in \{0,1\}^n$ in the work register $\sV_{work}$. %Copy the string $(1^n,w,r,G,V,M)$ to register $\sV_{in}$. 
Simulate $V_{UEVC}$ on input $(1^n,w,r,G,V,M)$ for $p(n)$ steps using TMSIM. Let register $\sV_m$ contain the contents of the measurement specification tape of $V_{UEVC}$.   Execute CKTSIM on the part of register $\sV_{work}$ that contains the contents of the measurement specification tape of $V_{UEVC}$ and register $\sC$, writing the classical output $s$ into $\sV_{work}$.
%registers $\sV_{m}$ (circuit description) and $\sC$, writing the classical output in register $\sV_{mo}$.
        \item (\textbf{Questions circuit}) Simulate $V_{UEVC}$ for $p(n)$ additional steps, using $s$ to specify the contents of the measurement outcome tape.
        %using register $\sV_{mo}$ to specify the contents of the measurement outcome tape. 
        Let registers $\sM_{i}$, $i\in\{1,\ldots,\kappa(r)\}$, contain the contents of the prover question tape of $V_{UEVC}$.
        \item (\textbf{Prover query}) Query prover $i$ for $i \in \{1,\ldots,\kappa(r)\}$. 
        \item (\textbf{Decision circuit}) Simulate $V_{UEVC}$ for $p(n)$ additional steps, using registers $\sM_{i}$ to specify the contents of the prover answer tape. Write the decision bit that is on the referee decision tape onto the first qubit of $\sV_{work}$.
    \end{enumerate}
\end{minipage}
}

\end{center}
\caption{Description of quantum circuit \textsc{$UEVC_{n,r}$}}
\label{fig:uevc}
\end{figure}

Let $\tau(n,r)$ denote the circuit size of $UEVC_{n,r}$. To complete the description of the circuit it remains to describe the GTM $G_{UEVC}$. \tnote{At some point we need to clarify how large $r$ is allowed to be, as a function of $n$}

\begin{lemma}
	There exists a GTM $G_{UEVC}$ such that on input $(n,r,t)$, three integers written in binary and such that $1 \leq t \leq \tau(n,r)$, computes the $t$-th gate of the circuit $UEVC_{n,r}$ in time $\poly\log(n) + \poly \log(r)$.
\end{lemma}

\begin{proof}
	Given $(n,r,t)$, it is straightforward to compute which of the four steps of $UEVC_{n,r}$ described above the time $t$ corresponds to. Here we use the fact that the phases of $V$ are run for exactly $p(n)$ steps. Furthermore, the description of $V_{UEVC}$ is hardwired into $G_{UEVC}$.
	
	If $t$ is a gate in the measurement circuit, it is either a gate used to generate the random string $w$, or a gate used to copy inputs between different registers, or a gate of TMSIM, or a gate of CKTSIM. Which case holds can be determined easily.
	
	If $t$ is a gate in the questions circuit, it is either a gate used to copy inputs between different registers, or a gate of TMSIM. Which case holds can be determined easily.
	
	If $t$ corresponds to a query to prover $i$, then $G(n,r,t)$ will output a gate whose label is ``Query prover $i$.'' 
	
	If $t$ is a gate in the decision circuit, it is either a gate used to copy inputs between different registers, or a gate of TMSIM. Which case holds can be determined easily.
	

\end{proof}


\section{Subroutines of the VTM $V_{UEVC}$}

Here we will detail the subroutines of the VTM $V_{UEVC}$. Each subroutine is a test that, if passed with high enough probability, forces rigidity of the provers. With each subroutine, we will write the corresponding rigidity statements.

The $r$'th level verifier implemented by the circuit $UEVC_{n,r}$ on input $(G_{UEVC},V_{NV},M)$ will interact with a set $\mathcal{P}_r$ of $\kappa(r)$ provers, each playing different roles. The $r$'th level verifier will check that the provers hold a history state of the protocol that's carried by the $(r-1)$-level verifier (that is represented by the circuit $UEVC_{N,r-1}$ for $N = 2^n$) and the set of provers $\mathcal{P}_{r-1}$. 

The provers in the set $\mathcal{P}_r$ will have the following labels and associated roles:
\begin{itemize}
	\item $PV$: This prover will play the role of $UEVC_{N,r-1}$
	\item $PP_1,\ldots,PP_{\kappa(r-1)}$: These provers will play the role of the $\kappa(r-1)$ provers that $UEVC_{N,r-1}$ interacts with.
	\item $PA_1,\ldots,PA_{\sigma(r)}$: These are ancillary provers.
\end{itemize}

In the subroutines below, the questions and answers to the provers will be denoted $q_V$, $q_{P,1},\ldots,q_{P,\kappa(r-1)}$, $q_{A,1},\ldots,q_{A,\sigma(r)}$, $a_V$, $a_{P,1},\ldots,a_{P,\kappa(r-1)}$, $a_{A,1},\ldots,a_{A,\sigma(r)}$, respectively.

%In this test, the ``current level'' verifier will interact with a subset of $\kappa(r-1) + 1$ provers. One of the provers, which we call $P_V$, will play the role of the ``next level'' verifier. The other provers, which we will label $P_1,\ldots,P_{\kappa(r-1)}$, will play the role of the $\kappa(r-1)$ provers that $UEVC_{N,r-1}$ interacts with. 


%In each subroutine below, the verifier will interact with a subset of provers; for each subroutine we will treat the labels of the provers in the subset as an input. For example, in the subroutine \textsc{Propagation Check}, the verifier will interact with a set of provers labeled by $P_1,\ldots,P_{\kappa(r-1)},P_V$; the questions to these provers will be denoted by $q_1,\ldots,q_{\kappa(r-1)},q_V$, respectively. Similarly, the answers from these provers will be denoted by $a_1,\ldots,a_{\kappa(r-1)},a_V$, respectively.

Furthermore, in what follows, we will write $\sC^N$, $\sV_{in}^N,\sV_{work}^N$, and $\{ \sM_i^N \}_i$ to denote the registers that $UEVC_{N,r-1}$ acts on. We will let $\sM^N$ denote the union of $\{ \sM_i^N \}_i$, and we will let $\sV^N$ denote the union of $\sC^N$, $\sV_{in}^N,\sV_{work}^N$, and $\sM^N$. For a given register $\sR$, we will write $\supp(\sR)$ to denote the set of qubits in $\sR$.

%%%%%%%%%%%%%%%%%%%%%%%%%%		PAULI CHECK		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Pauli check}
\label{sec:pauli_check}


\begin{figure}[H]
\begin{center}
\framebox{
\begin{minipage}{0.9\textwidth}
    Input: $(1^n,w,r,G,V,M)$ \\
		The verifier interacts with two players, A and B. The role of A is played by prover $PA_1$. The role of B is played by prover $PV$. See ``question types'' for a description of the format of the questions to the players. \\
		The verifier performs one of the following tests, chosen uniformly at random. In each test, the verifier performs a measurement on a subset of the qubits in register $\reg{C}$ identified as the clock qubits for the Pauli check. This register has dimension $2(N+1)$, and contains a bit $d$ followed by an integer $t\in\{0,\ldots,N\}$ written in binary. For clarity, we keep the label $\reg{C}$ for the register containing the relevant qubits. \tnote{This is a bit convoluted. But there are different clocks this verifier holds. I don't know if we want to give each one a name}
	\begin{enumerate}
 \item \emph{(EPR test)} Measure register $\reg{C}$ in the computational basis. Accept if the outcome $(d,t)\neq (0,0)$. Execute the $2N$-qubit EPR test with A and B.\\
\tnote{Intended goal: Checks that whenever A or B is sent an EPR question, it applies the corresponding Pauli observable, independently of any other question asked. A consequence of this test and the form of questions to player B is that we can write the observables it applies as a product of an observable for the EPR question, and an observable for the Pauli question, where each observable only depends on the corresponding question (and not on the pair of questions).}

\item \emph{(Propagation check)} Let $t\in\{0,\ldots,N-1\}$ and $d\in\{0,1\}$ be chosen uniformly at random. Measure register $\reg{C}$ using the three-outcome POVM
$$\Big\{ \Pi^0 = \proj{d} \otimes \proj{+_t},\; \Pi^1 =  \proj{d} \otimes \proj{-_t},\;\Pi^2 = \Id - \Pi^0-\Pi^1 \Big\}\;,$$
where $\ket{\pm_t} = \frac{1}{\sqrt{2}}(\ket{t}\pm\ket{t+1})$. If the outcome is $c=2$, accept. Otherwise, if $d=0$, send $B$ the question $CZ_{t}$. If $d=1$, send B the question $CX_t$. Check that the answer reported by B equals $(-1)^c$, where $c\in\{0,1\}$ is the outcome obtained by the verifier.\\
\tnote{Intended goal: Check that the state shared by the players takes the form of a history state, where the reflection applied on Bob's registers $BB'$ at step $2$ only acts on register $B$ and the appropriate qubit of $B'$.}

\item \emph{(CTL check)} Measure register $\reg{C}$ in the computational basis to obtain an outcome $(d,t)$. Send player A the EPR question $X'_{n+t}$ ($d=1$) or $X'_t$ ($d=0$). Either:
\begin{enumerate}
\item Send player B the same EPR question as player A, as well as the Pauli question $X_t$ (if $d=1)$ or $Z_t$ (if $d=0$).  Reject if the product of the three answer bits received is not $1$.
\item Send player B the same EPR question as player A, as well as the CTL-Pauli question $CX_t$ ($d=1)$ or $CZ_t$ ($d=0$).  Reject if B's second answer is not $1$, or if A's answer and B's first answer do not match.
\end{enumerate}
\tnote{Intended goal: Check that the reflection applied by B on question $CX_i$ (resp. $CZ_j$) is a controlled observable, controlled on the qubit in register $B'_i$ (resp. $B'_{n+j}$) only, and that it matches the observable applies on question $X_i$ (resp. $Z_j$), which only acts on register $B$.}
	\end{enumerate}    
\end{minipage}
}
\end{center}
\caption{Pauli Check}
\label{fig:pauli_check}
\end{figure}


\paragraph{Question types}
There are three types of questions: ``EPR questions'', ``Pauli questions'' and ``CTL-Pauli questions''. 
\begin{itemize}
\item \emph{EPR questions} range over the question set of the $2N$-qubit EPR test \tnote{this needs to be defined somewhere}. They are of the form $X'_i$ or $Z'_j$, for $i,j\in\{1,\ldots,2N\}$, or $(V'_i,W'_j)$ for $V,W\in\{X,Z\}$ and $i\neq j \in \{1,\ldots,2N\}$. \tnote{In fact there are additional question types involved, but these are the more relevant ones} 
\item \emph{Pauli questions} range over the set of subsets 
$$\{W_1(w_1),W_2(w_2),W_3(w_3)\}\,\subseteq\,\{X(a),Z(b)\,|\; a,b\in\{0,1\}^N\}$$
 of cardinality at most $3$, and such that all (at most) three Pauli operators $W_i(w_i)$ in the set mutually commute, and all strings $w_i$ have Hamming weight at most $3$.
\item \emph{CTL-Pauli questions} range over the set $\{CX_i,CZ_j|i,j\in\{1,\ldots,N\}\}$.
\end{itemize}
The test is played with two players, player A and player B. Player A is always sent an EPR question. Player B is always sent a pair consisting of an EPR question and a Pauli, or CTL-Pauli question. In the test as described in Figure~\ref{fig:pauli_check} Pauli questions consist of a single Pauli operator. In fact, the Pauli question is always embedded in a triple of commuting Pauli operators of weight at most $3$, where the other two operators are chosen uniformly among pairs that mutually commute and commute with the ``real'' question. In addition, even if the test only calls for a Pauli question, an EPR question is asked and chosen at random. (For a CTL-Pauli question of the form $CX_i$ (resp. $CZ_j$), the EPR question can be any question not involving the index $i$ (resp. $n+j$).) In all cases, only the player's answer to the ``real'' question is taken into account in the verifier's decision. 

\paragraph{The honest strategy}
The players share a state of the form~\eqref{eq:honest-psi}, where $\ket{\psi}_{\reg{BR}}$ is arbitrary and $\{X_i,Z_j:\, i,j\in\{1,\ldots,N\}\}$ are observables on $\mathcal{H}_\reg{B}$ that satisfy the Pauli relations. For $a,b\in \{0,1\}^N$ and $t\in\{0,\ldots,n\}$ let $X(a_{\leq t}) = X_t^{a_t}\cdots X_1^{a_1}$ and $Z(b_{\leq t}) = Z_t^{b_t}\cdots Z_1^{b_1}$. We also write $X(a)$ and $Z(b)$ for $X(a_{\leq N})$ and $Z(b_{\leq N})$ respectively. 

Player A applies the honest strategy for the EPR test, using the $2N$-qubit register $\reg{A}'$. On EPR questions Player B applies the  honest strategy for the EPR test, using the $2N$-qubit register $\reg{B}'$. On Pauli questions, player B uses the family of observables $X(a),Z(b)$ on $\reg{B}$ to determine his $3$-bit answer. On a CTL-Pauli question of the form $CX_i$ (resp $CZ_j$), the observable is controlled on the $i$-th qubit (resp. $N+j$-th qubit) of register $\reg{B}'$. 

\paragraph{Guarantees}
The following lemma states completeness of the check. 

\begin{lemma}[Completeness of the Pauli check]
Let $\ket{\psi}_{\reg{BR}} \in \cH_\reg{B} \otimes \cH_\reg{R}$ be a state, such that $\reg{B}$ is an $N$-qubit quantum register. Let $X(a)$ and $Z(b)$, for $a,b\in\{0,1\}^N$, be Pauli operators on $\reg{B}$. Let $\reg{A}'$, $\reg{B}'$ be $2N$-qubit registers, and 
\begin{equation}\label{eq:honest-psi}\ket{\Psi}_{\reg{ABR}} \,=\, \frac{1}{\sqrt{2(N+1)}} \sum_{d\in\{0,1\},t\in\{0,\ldots,N\}} \ket{d,t}_{\reg{C}}  \frac{1}{2^N} \sum_{a,b \in \{0,1\}^N} \ket{a,b}_{\reg{A}'} \ket{a,b}_{\reg{B}'} \big(\Id_A \otimes X(d\cdot a_{\leq t}) Z(b_{\leq t})\otimes \Id_R\big)\ket{\psi}_\reg{ABR}\;.
\end{equation}
Then there exists a strategy for players A and B sharing state $\ket{\Psi}_{\reg{ABR}}$ that succeeds with probability $1$ in the Pauli check.  
\end{lemma}

The next lemma states soundness of the check.


\begin{lemma}[Soundness of the Pauli check]
Suppose players A and B sharing state $\ket{\psi}_{\reg{CABR}}$ succeed with probability at least $1-\eps$ in the Pauli check. Here $\reg{C}$ is the register sent to the verifier, $\reg{A}$ and $\reg{B}$ are held by A and B respectively, and $\reg{R}$ is arbitrary. 

Then there exists a $\delta = \poly(n,\eps)$ and local isometries $V_A: \cH_A \to \cH_A \otimes \cH_{A'}$, $V_B:\cH_{B}\to  (\C^2)^{\otimes N} \otimes \cH_{B'} \otimes \cH_{B''}$ such that   for all Pauli questions $(W_1(w_1),W_2(w_2),W_3(w_3))$ and all triples of answers $(a_1,a_2,a_3)$, if $W^{abc}$ is the associated POVM for player B then 
$$ \sum_{a,b,c\in\{\pm1\}}\big\| \Id_{\reg{CAR}}\otimes  V_B W^{abc} \ket{\psi}_{\reg{CABR}} -  \Id_{\reg{CAR}}\otimes\sigma_{W_1}(w_1)^{a_1} \sigma_{W_2}(w_2)^{a_2}\sigma_{W_3}(w_3)^{a_3}V_B \ket{\psi}_{\reg{CABR}} \big\|^2 \,=\,O(\delta)\;.$$
Moreover, \tnote{Do we need this part? Seems like the only thing we want is the Pauli operators, we don't care about the form of the state?}
\begin{equation}\label{eq:hist-epr-state}
V_A \otimes V_B \otimes \Id_{CR} \ket{\psi}_\reg{CABR} \approx_\delta \frac{1}{\sqrt{2(N+1)}} \sum_{d\in\{0,1\},t\in\{0,\ldots,N\}} \ket{d,t}_{C}  \frac{1}{2^N} \sum_{a,b \in \{0,1\}^N} \ket{a,b}_{A'} \ket{a,b}_{B'} \big(\Id_A \otimes X(d\cdot a_{\leq t}) Z(b_{\leq t})\otimes \Id_R\big)\ket{\psi}_\reg{ABR}\;.
\end{equation}

\end{lemma}

\tnote{The next lemma will be part of the proof of the soundness analysis. For now, ignore it}

\begin{lemma}
Let $\{X_i,Z_j:\, i,j\in\{1,\ldots,n\}\}$ be observables on $\mathcal{H}_B$, and $\ket{\psi}_{BR}$ a state on $\mathcal{H}_B\otimes \cH_R$ such that  on average over $a,b\in\{0,1\}^n$ and $i,j\in\{1,\ldots,n\}$,
\begin{align}
\Id_A \otimes X_i X(a) Z(b)\otimes \Id_R \ket{\psi}& \approx_\delta \Id_A \otimes X(a+e_i)Z(b) \otimes \Id_R \ket{\psi}_{ABR}\label{eq:x-com}\\
\Id_A \otimes Z_i X(a) Z(b)\otimes \Id_R \ket{\psi}& \approx_\delta \Id_A \otimes (-1)^{a_i} X(a)Z(b+e_i) \otimes \Id_R \ket{\psi}_{ABR}\;,\label{eq:z-com}
\end{align}
for some error $\delta$. Then there is an isometry $V:\cH_B \to (\C^2)^{\otimes n} \otimes \cH_{B''}$ such that 
$$ \Es{i} \big\|  VX_i \ket{\psi} -  \sigma_X(e_i) V\ket{\psi} \big\| + \Es{j} \big\| VZ_j \ket{\psi} - \sigma_Z(e_j) V\ket{\psi} \big\| \,=\,O(\delta)\;,$$
where $\sigma_X(e_i)$ (resp. $\sigma_Z(e_j)$) acts on the $i$-th (resp. $j$-th) copy of $\C^2$ in the range of $V$. 
\end{lemma}

\begin{proof}
The relations~\eqref{eq:x-com} and~\eqref{eq:z-com} are sufficient to verify that $X(a)Z(b)$ is an approximate representation of the Pauli group, and apply the Gowers-Hatami theorem.
\end{proof}



%%%%%%%%%%%%%%%%%%%%%%%%%%		PROPAGATION CHECK		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Propagation check}
\label{sec:prop_check}


\begin{figure}[H]
\begin{center}
\framebox{
\begin{minipage}{0.9\textwidth}
    Input: $(1^n,w,r,G,V,M)$ \\
    
	\begin{enumerate}
		\item (\textsc{ClockMeasurement}) Use $w$ to select a time $1 \leq t \leq \tau(N)$, where $N = 2^n$. Write a description for the circuit $C_M$ that implements the POVM $F_t$ into the measurement specification tape. This POVM is defined as follows:
\begin{align}
	F_t^+ := \frac{1}{2} (\ket{t} + \ket{t+1})(\bra{t} + \bra{t+1}) \\
	F_t^- := \frac{1}{2} (\ket{t} - \ket{t+1})(\bra{t} - \bra{t+1}) \\
	F_t^\bot := \Id - F_t^+ - F_t^-.
\end{align}

		\item (\textsc{GenQuestions}) Execute the GTM $G$ to compute $g = G(N,r-1,t)$. If $g$ is a verifier gate, compute questions as in the Verifier Gate Check. If $g$ is a prover query, compute questions as in the Prover Gate Check.
		\item (\textsc{CheckAnswers}) Compute the decision in the referee decision tape, using the contents of the player answer tape. 
	\end{enumerate}    
\end{minipage}
}

\end{center}
\caption{Propagation Check}
\label{fig:prop_check}
\end{figure}

\paragraph{The high level} At a high level, this test will perform the following. The $r$'th level verifier will sample a random time $t \in \{1,\ldots,\tau(N)\}$, and compute the $t$'th gate $g_t$ of $UEVC_{N,r-1}$ using the GTM $G = G_{UEVC}$. Most of the time, the gate $g_t$ will be a (doubled) Hadamard or Toffoli gate that's computed by the $(r-1)$-level verifier $UEVC_{N,r-1}$. To check the propagation of such a gate, the $r$-level verifier will run the corresponding Hamadard or Toffoli Check (see~\cite{ji2016compression}) to generate the corresponding questions. If the gate $g_t$ does not act on any of the $\{ \sM_i\}$ register of $UEVC_{N,r-1}$, then the Hadamard/Toffoli check questions are sent to prover $PV$. If $g_t$ acts partially on the $\sM_i$ register, then the questions are partially sent to $PV$, and partially sent to $PP_i$. If $g_t$ acts fully on $\sM_i$, then all the questions are sent to $PP_i$.

Sometimes, the gate $g_t$ will not be a gate at all, but rather it will represent the $i$'th prover's unitary. In that case, prover $i$ will be sent the question $\star$.  

Any prover who was not explicitly sent a question will receive a null question, denoted by $\bot$.

\paragraph{Question types} There are two types of questions asked in this test: Pauli operations, and a prover reflection query $\star$.


\paragraph{The honest strategy} For all $0 \leq t \leq \tau(N)$, let $g_t = G(N,r-1,t)$. An honest Pauli strategy $\mathcal{S}$ is an honest Propagation strategy if the shared state has the following form:
\[
	\ket{\psi}_{\sC \sP \sR} = \frac{1}{\sqrt{\tau(N) + 1}} \sum_{t = 0}^{\tau(N)} \ket{t}_{\sC} \otimes \ket{\psi_t}_{\sC \sP \sR}
\]
where the $r$'th level verifier holds register $\sC$ and the provers $PP_1,\ldots,PP_{\kappa(r-1)},PV$ jointly hold $\sP$. The register $\sP$ itself is decomposed into a tensor product of registers $\sC^N, \sV^N_{in}, \sV^N_{work}$ (all held by prover $PV$) and registers $\{ \sM_i^N \}$ (held by provers $\{ PP_i \}$). We can assume that the register $\sP$ has this tensor product structure because the strategy is an honest Pauli strategy. Furthermore, we also emphasize that the registers $\sC$ are $\sC^N$ are distinct: the first one is the clock register for the $r$-level verifier, and $\sC^N$ is the clock register for the $(r-1)$-level verifier.

The register $\sR$ is some purifying register (part of which may be shared by the verifier and provers). For all $t$, the state $\ket{\psi_t}_{\sC \sP \sR}$ is defined to be $g_t \ket{\psi_{t-1}}_{\sP \sR}$ with $g_t$ being either a doubled Hadamard, a Toffoli, or a prover reflection acting on the correct registers. The state $\ket{\psi_0}$ is arbitrary.

\begin{theorem}	
\label{thm:prop_check}
The honest Propagation strategy passes the $\textsc{Propagation Check}(n)$ subprotocol with probability $1$. All honest Pauli strategies $\mathcal{S}$ that pass the $\textsc{Propagation Check}(n)$ subprotocol with probability at least $1 - \eps$ is $\poly(n,\eps)$-close to an honest Propagation Check strategy.
\end{theorem}


%%%%%%%%%%%%%%%%%%%%%%%%%%		INPUT CHECK		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Input check}
\label{sec:input_check}

\begin{figure}[H]
\begin{center}
\framebox{
\begin{minipage}{0.9\textwidth}
    Input: $(1^n,w,r,G,V,M)$
    %\hnote{The input register to $UEVC_{N,r}$ is $\alpha N$-bits long.}
    
	\begin{enumerate}
		\item (\textsc{ClockMeasurement}) Write the circuit $C_M$ that measures $\sC$ in the computational basis, with the outcome being $t$.
		\item (\textsc{GenQuestions}) If $t$ is not $0$, then continue to the \textsc{CheckAnswers} phase. Otherwise, pick a random qubit $j \in \supp(\sV^N \setminus \{\sC^N \})$. 
		\begin{itemize}
			\item If $j \in \supp(\sM_i^N)$, set $q_{P,i} = Z_j$.
			\item If $j \notin \supp(\sM_i^N)$, set $q_V = Z_j$.
		\end{itemize}
		
		\item (\textsc{CheckAnswers}) 
		\begin{itemize}
			\item If $t \neq 0$, then accept. 
			\item If $j \notin \supp(\sV_{in}^N \setminus \sM^N)$ and $a_V = 0$, then accept. 
			\item If $j \in \supp(\sV_{in}^N)$ and $a_V$ is equal to the $j$'th bit of the string that is $(G,V,M)$ padded by $0$, then accept. 
			\item If $j \in \supp(\sM_i^N)$ and $a_{P,i} = 0$, then accept.
			\item Otherwise, reject.
		\end{itemize}
	\end{enumerate}    
\end{minipage}
}

\end{center}
\caption{Input Check}
\label{fig:input_check}
\end{figure}

\paragraph{The high level} First, we will assume that the strategy is an honest \textsc{Propagation Check} strategy (and thus an honest Pauli strategy), meaning that the provers will share a history state of the protocol between the $(r-1)$-level verifier $UEVC_{N,r-1}$ and a number of provers. The \textsc{Input Check} subroutine will check that in the first snapshot of the history state, the prover $PV$ (which is supposed to play the role of $UEVC_{N,r-1}$) has the $\sV_{in}^N$ register initialized to the input $(G,V,M)$, and $\sV_{work}^N $ set to zeroes. Furthermore, the subroutine will check that the $PP_i$ prover has the message register $\sM_i^N$ set to all zeroes.

\paragraph{Honest strategy}
An honest Propagation Check strategy $\mathcal{S}$ with shared state
\[
	\ket{\psi}_{\sC \sP \sR} = \frac{1}{\sqrt{\tau(N) + 1}} \sum_{t = 0}^{\tau(N)} \ket{t}_{\sC} \otimes \ket{\psi_t}_{\sC \sP \sR}
\]
is an honest Input Check strategy if the initial state $\ket{\psi_0}_{\sP \sR}$ is such that the $\sV^N_{in}\sV^N_{work} \sM^N$ registers are in the state $\ket{G,V,M} \otimes \ket{0}$. In other words, the $(r-1)$-level verifier is properly initialized.

%For all $0 \leq t \leq \tau(N)$, let $g_t = G(N,r-1,t)$. A strategy $\mathcal{S}$ is an honest Propagation strategy if the Pauli operators are trusted and the shared state has the following form:
%where $\ket{\psi_t}_{\sP \sE} = g_t \ket{\psi_{t-1}}_{\sP \sE}$ with $g_t$ being either a doubled Hadamard, a Toffoli, or a prover reflection. The state $\ket{\psi_0}$ is arbitrary.



\begin{theorem}	
\label{thm:input_check}
The honest Input Check strategy passes the $\textsc{Input Check}(n)$ subprotocol with probability $1$. All honest Propagation Check strategies $\mathcal{S}$ that pass the $\textsc{Input Check}(n)$ subprotocol with probability at least $1 - \eps$ is $\poly(n,\eps)$-close to the honest Input Check strategy.
\end{theorem}

%%%%%%%%%%%%%%%%%%%%%%%%%%		OUTPUT CHECK		%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Output check}
\label{sec:output_check}


\begin{figure}[H]
\begin{center}
\framebox{
\begin{minipage}{0.9\textwidth}
    Input: $(1^n,w,r,G,V,M)$
	\begin{enumerate}
		\item (\textsc{ClockMeasurement}) Write the circuit $C_M$ that measures $\sC$ in the computational basis, with the outcome being $t$.
%		Use $w$ to select a time $1 \leq t \leq \tau(N)$, where $N = 2^n$. Write a description for the circuit $C_M$ that implements the POVM $F_t$ into the measurement specification tape.
		\item (\textsc{GenQuestions}) Set $q_V = \supp(\sV^N_{work})_1$ (i.e. the first qubit of $\sV^N_{work}$).
		\item (\textsc{CheckAnswers}) If $t \neq \tau(N)$, then accept. If $a_V = 1$, then accept. Otherwise, reject.
	\end{enumerate}    
\end{minipage}
}


\end{center}
\caption{Output Check}
\label{fig:output_check}
\end{figure}


\paragraph{The high level} The \textsc{Output Check} checks that the last snapshot $\ket{\psi_{\tau(N)}}$ of the history state has the output qubit (the first qubit of the workspace register) set to $1$ (or close to it). To do so, the subroutine will command the prover $PV$ to measure  qubit $\supp(\sV^N_{work})_1$ in the computation basis. 

% post-selects on the clock register $\sR$ in reading the last time $\tau(N)$ of the circuit, and the verifier will ask prover $1$ to measure its first qubit in the computational basis, which should correspond to the output bit of the history state. 

%\paragraph{Honest strategy} 

\begin{theorem}	
\label{thm:output_check}
Let $\omega_{N,r-1}$ denote the maximum acceptance probability of the protocol that is executed by the verifier $UEVC_{N,r-1}$ on input $(G_{UEVC},V_{NV},M)$. All honest Input Check strategies pass the $\textsc{Output Check}(n)$ subprotocol with probability at most 
\[
	1 - \frac{1 - \omega_{N,r-1}}{\poly(N)}.
\] %All honest Input Check strategies $\mathcal{S}$ that pass the $\textsc{Output Check}(n)$ subprotocol with probability at least $1 - \eps$ is $\poly(n,\eps)$-close to an honest Output Check strategy.
\end{theorem}




\bibliography{recursive}
\bibliographystyle{alpha}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
